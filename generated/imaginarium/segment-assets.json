[
  {
    "segmentId": "seg-f92c619f",
    "palette": {
      "primary": "#8fb9a9",
      "secondary": "#62888a",
      "accent": "#b2e7ff",
      "background": "#010403",
      "glow": "#ddffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.540823996531185,
      "seed": 364
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-f92c619f-c904da8a",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: c904da8a377a6752abb8b5df3d137c2ad419156df664794881b6b95fe59414a7\n// Variant: segment-seg-f92c619f\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5607843137254902,
        "u_color1.g": 0.7254901960784313,
        "u_color1.b": 0.6627450980392157,
        "u_color2.r": 0.3843137254901961,
        "u_color2.g": 0.5333333333333333,
        "u_color2.b": 0.5411764705882353,
        "u_color3.r": 0.6980392156862745,
        "u_color3.g": 0.9058823529411765,
        "u_color3.b": 1,
        "u_glow.r": 0.8666666666666667,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.011764705882352941,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-b60ccac7",
    "palette": {
      "primary": "#8fb9a9",
      "secondary": "#62888a",
      "accent": "#b2e7ff",
      "background": "#010403",
      "glow": "#ddffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.5760422483423212,
      "seed": 58149
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-b60ccac7-711f790a",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 711f790a466c419e9bbaae7849c0b643b6b8a888e5552256d73640f53c5366e6\n// Variant: segment-seg-b60ccac7\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5607843137254902,
        "u_color1.g": 0.7254901960784313,
        "u_color1.b": 0.6627450980392157,
        "u_color2.r": 0.3843137254901961,
        "u_color2.g": 0.5333333333333333,
        "u_color2.b": 0.5411764705882353,
        "u_color3.r": 0.6980392156862745,
        "u_color3.g": 0.9058823529411765,
        "u_color3.b": 1,
        "u_glow.r": 0.8666666666666667,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.011764705882352941,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-d45a5af1",
    "palette": {
      "primary": "#92b3cb",
      "secondary": "#767f9a",
      "accent": "#e4d5ff",
      "background": "#010407",
      "glow": "#e2ffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.4204119982655925,
      "seed": 38605
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-d45a5af1-d0c9b060",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: d0c9b06081f322a4e966d6f35fb312137eae180d4e981719c71304f2d1553635\n// Variant: segment-seg-d45a5af1\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5725490196078431,
        "u_color1.g": 0.7019607843137254,
        "u_color1.b": 0.796078431372549,
        "u_color2.r": 0.4627450980392157,
        "u_color2.g": 0.4980392156862745,
        "u_color2.b": 0.6039215686274509,
        "u_color3.r": 0.8941176470588236,
        "u_color3.g": 0.8352941176470589,
        "u_color3.b": 1,
        "u_glow.r": 0.8862745098039215,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.027450980392156862,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-8614d34e",
    "palette": {
      "primary": "#4389cc",
      "secondary": "#92492f",
      "accent": "#c3ab00",
      "background": "#00030e",
      "glow": "#64d7ff",
      "mood": "cool"
    },
    "noise": {
      "type": "fbm",
      "octaves": 2,
      "frequency": 1.35,
      "amplitude": 0.7954242509439325,
      "seed": 49743
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-8614d34e-ca615d6a",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: ca615d6a6996b835bcff7cef86fc73c3136b7f4f8fd79141a1ad637390be099a\n// Variant: segment-seg-8614d34e\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=2, freq=1.35\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.2627450980392157,
        "u_color1.g": 0.5372549019607843,
        "u_color1.b": 0.8,
        "u_color2.r": 0.5725490196078431,
        "u_color2.g": 0.28627450980392155,
        "u_color2.b": 0.1843137254901961,
        "u_color3.r": 0.7647058823529411,
        "u_color3.g": 0.6705882352941176,
        "u_color3.b": 0,
        "u_glow.r": 0.39215686274509803,
        "u_glow.g": 0.8431372549019608,
        "u_glow.b": 1,
        "u_background.r": 0,
        "u_background.g": 0.011764705882352941,
        "u_background.b": 0.054901960784313725,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-cd75ab05",
    "palette": {
      "primary": "#92b3cb",
      "secondary": "#767f9a",
      "accent": "#e4d5ff",
      "background": "#010407",
      "glow": "#e2ffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.6266936911159173,
      "seed": 53670
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-cd75ab05-aca93fd3",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: aca93fd3b1dd37faaac90d53a08bf3dfe57d73205dfe359b5b88922b1328b01e\n// Variant: segment-seg-cd75ab05\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5725490196078431,
        "u_color1.g": 0.7019607843137254,
        "u_color1.b": 0.796078431372549,
        "u_color2.r": 0.4627450980392157,
        "u_color2.g": 0.4980392156862745,
        "u_color2.b": 0.6039215686274509,
        "u_color3.r": 0.8941176470588236,
        "u_color3.g": 0.8352941176470589,
        "u_color3.b": 1,
        "u_glow.r": 0.8862745098039215,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.027450980392156862,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-a8d30542",
    "palette": {
      "primary": "#8fb9a9",
      "secondary": "#62888a",
      "accent": "#b2e7ff",
      "background": "#010403",
      "glow": "#ddffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.6848558572123764,
      "seed": 14574
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-a8d30542-deafbd43",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: deafbd43845ff4ea17e45e4ef9f2d65e913715dcd50c37a66d4492512742015b\n// Variant: segment-seg-a8d30542\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5607843137254902,
        "u_color1.g": 0.7254901960784313,
        "u_color1.b": 0.6627450980392157,
        "u_color2.r": 0.3843137254901961,
        "u_color2.g": 0.5333333333333333,
        "u_color2.b": 0.5411764705882353,
        "u_color3.r": 0.6980392156862745,
        "u_color3.g": 0.9058823529411765,
        "u_color3.b": 1,
        "u_glow.r": 0.8666666666666667,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.011764705882352941,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-fc2f246e",
    "palette": {
      "primary": "#7cb8cc",
      "secondary": "#6683a2",
      "accent": "#d2d8ff",
      "background": "#000407",
      "glow": "#beffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 2,
      "frequency": 1,
      "amplitude": 0.6204119982655925,
      "seed": 18415
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-fc2f246e-c53abb65",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: c53abb6548307de60e5e65bd4f9e4d544a3213c726f596744e61bb5b8e9fcdbc\n// Variant: segment-seg-fc2f246e\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=2, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.48627450980392156,
        "u_color1.g": 0.7215686274509804,
        "u_color1.b": 0.8,
        "u_color2.r": 0.4,
        "u_color2.g": 0.5137254901960784,
        "u_color2.b": 0.6352941176470588,
        "u_color3.r": 0.8235294117647058,
        "u_color3.g": 0.8470588235294118,
        "u_color3.b": 1,
        "u_glow.r": 0.7450980392156863,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.027450980392156862,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-7e814371",
    "palette": {
      "primary": "#0088f4",
      "secondary": "#aa3400",
      "accent": "#d3a900",
      "background": "#000216",
      "glow": "#00d5ff",
      "mood": "cool"
    },
    "noise": {
      "type": "fbm",
      "octaves": 4,
      "frequency": 1.302439024390244,
      "amplitude": 0.8010299956639813,
      "seed": 35791
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-7e814371-8db196e5",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 8db196e5f3870727f97994c5cd096082f54ed479b488bdaf618d5602b16aa76f\n// Variant: segment-seg-7e814371\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=4, freq=1.302439024390244\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0,
        "u_color1.g": 0.5333333333333333,
        "u_color1.b": 0.9568627450980393,
        "u_color2.r": 0.6666666666666666,
        "u_color2.g": 0.20392156862745098,
        "u_color2.b": 0,
        "u_color3.r": 0.8274509803921568,
        "u_color3.g": 0.6627450980392157,
        "u_color3.b": 0,
        "u_glow.r": 0,
        "u_glow.g": 0.8352941176470589,
        "u_glow.b": 1,
        "u_background.r": 0,
        "u_background.g": 0.00784313725490196,
        "u_background.b": 0.08627450980392157,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-2921c7fc",
    "palette": {
      "primary": "#83a3bb",
      "secondary": "#6b748e",
      "accent": "#d1c2ef",
      "background": "#010407",
      "glow": "#cbffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1.5,
      "amplitude": 0.613640344813399,
      "seed": 39950
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-2921c7fc-c8a26dea",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: c8a26dea2772e4b6a08224a93c5b7f5ea5533812f8e7d82e41b111a53b89d5f1\n// Variant: segment-seg-2921c7fc\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.5\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5137254901960784,
        "u_color1.g": 0.6392156862745098,
        "u_color1.b": 0.7333333333333333,
        "u_color2.r": 0.4196078431372549,
        "u_color2.g": 0.4549019607843137,
        "u_color2.b": 0.5568627450980392,
        "u_color3.r": 0.8196078431372549,
        "u_color3.g": 0.7607843137254902,
        "u_color3.b": 0.9372549019607843,
        "u_glow.r": 0.796078431372549,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.027450980392156862,
        "time": 0
      },
      "complexity": 298
    }
  }
]
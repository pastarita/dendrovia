# OPERATUS - The Infrastructure

> **Philosophy:** "Local-First is the Ultimate MVP - We build the 'MMO' architecture, but run the 'Server' inside the browser (WASM/WebWorkers)."

## Responsibility

OPERATUS manages **all infrastructure** outside the game logic:

1. **Asset Loading** - Shaders, palettes, topology files
2. **OPFS Caching** - Origin Private File System (browser storage)
3. **State Persistence** - Save/load game progress
4. **CDN Delivery** - Optional "HD pack" streaming
5. **(Future) SpaceTimeDB** - Optional MMO backend

## Core Principle: Zero Server Cost Until Needed

**Local-First Architecture:**
- The game **fully works offline**
- Assets are bundled with the app (<1MB initial)
- Optional HD assets stream on-demand
- Multiplayer is **opt-in**, not required

## Cognitive Boundaries

**Dependencies:**
- IMAGINARIUM (loads generated artifacts)

**Consumers:**
- ARCHITECTUS (requests shaders/palettes)
- LUDUS (requests topology/commits)
- OCULUS (requests file contents)

**Interface:**
- Emits `GameEvents.ASSETS_LOADED` when ready
- Emits `GameEvents.STATE_PERSISTED` after save
- Provides async `loadAsset(id)` API

## Steering Heuristic

> "Build the API as if it were networked, but implement the Transport Layer as a local function call. Switch to WebSocket only when the local version is polished."

## Key Philosophies

### 1. The Distributed Dungeon

**Insight:** Every user's browser is a "shard."

We don't need a central server to start. We can share:
- **Dungeon Seeds** (Git repo URL + random seed)
- **High Scores** (via async leaderboards)
- **Notes** (via export/import)

Two players can:
1. Generate the **same procedural world** (deterministic)
2. Play it **independently**
3. Compare scores/discoveries **asynchronously**

### 2. Progressive Asset Loading

**Goal:** <1MB initial load, stream the rest.

```
Initial Bundle (1MB):
  ├─ Core engine code
  ├─ Basic shaders (fallback)
  ├─ UI framework
  └─ Default palette

Optional HD Pack (streaming):
  ├─ High-res textures
  ├─ Complex shaders
  ├─ Audio assets
  └─ Extended palettes
```

**User sees:**
- Instant load with "Default Beautiful" aesthetic
- Progressive enhancement as HD assets arrive

### 3. OPFS (Origin Private File System)

**Why OPFS?**
- **Faster than IndexedDB** (direct file I/O)
- **Private** (not accessible to other sites)
- **Persistent** (survives browser close)
- **Large storage** (quota in GB, not MB)

**Use Cases:**
- Cache AI-generated assets locally
- Store game save states
- Persist user preferences
- Pre-download large codebases

### 4. Manifest-Driven Loading

**How it works:**

```json
// manifest.json (generated by IMAGINARIUM)
{
  "version": "1.0.0",
  "checksum": "abc123...",
  "shaders": {
    "dendrite_main": "/generated/shaders/abc123.glsl",
    "bug_glow": "/generated/shaders/def456.glsl"
  },
  "palettes": {
    "default": "/generated/palettes/xyz789.json"
  },
  "topology": "/generated/topology.json"
}
```

On startup:
1. Load `manifest.json`
2. Check OPFS cache for assets (by checksum)
3. Load missing assets from CDN/bundle
4. Cache in OPFS for next session

## Implementation Status

- [ ] Asset loader (fetch + cache)
- [ ] OPFS integration
- [ ] State persistence (save/load)
- [ ] Manifest parser
- [ ] CDN integration
- [ ] SpaceTimeDB client (future)

## Asset Loading Flow

```typescript
// Example usage
const operatus = new Operatus();

// Initialize (loads manifest, checks cache)
await operatus.init();

// Load specific assets
const shader = await operatus.loadShader('dendrite_main');
const palette = await operatus.loadPalette('default');
const topology = await operatus.loadTopology();

// Emit event when ready
eventBus.emit(GameEvents.ASSETS_LOADED, {
  shaders: [shader],
  palettes: [palette],
  topology
});
```

## State Persistence

**What to save:**
- Character stats (health, mana, level)
- Quest progress (completed, active, available)
- Visited nodes (explored areas)
- Unlocked knowledge (discovered commits)
- User preferences (keybinds, volume)

**Storage:**
```typescript
interface GameSaveState {
  version: string;
  timestamp: number;
  character: Character;
  quests: Quest[];
  visitedNodes: string[];
  unlockedKnowledge: string[];
  preferences: UserPreferences;
}

// Save to OPFS
await operatus.saveState(state);

// Load from OPFS
const state = await operatus.loadState();
```

## CDN Strategy

**For Production:**

```
CDN (Cloudflare R2 / Vercel Blob):
  └─ /generated/
       ├─ shaders/
       ├─ palettes/
       └─ topology/

Browser:
  ├─ Bundle: 1MB (core)
  └─ OPFS Cache: 50MB (optional)
```

**Cache Invalidation:**
- Use content-based hashing (checksum in filename)
- Manifest version bump triggers re-download
- User can manually "Clear Cache" (OPFS flush)

## SpaceTimeDB Integration (Future)

**When to enable:**
- User has completed first quest (invested)
- User opts into "Shared World" mode
- Server costs justified by user base

**What it enables:**
- Shared quest progress (guild system)
- Leaderboards (fastest bug hunter)
- Asynchronous multiplayer (leave notes for others)

**Local-First Guarantee:**
- Server goes down → game still works offline
- No internet → full functionality (minus multiplayer)

## Performance Budget

| Metric | Target | Fallback |
|--------|--------|----------|
| Initial Load | <1MB | <500KB (minimal) |
| Time to Interactive | <2s | <5s (slow connection) |
| Asset Fetch | <100ms (cached) | <1s (network) |
| OPFS Write | <50ms | IndexedDB fallback |

## Future Enhancements

- [ ] Background asset pre-fetching
- [ ] Service Worker integration
- [ ] Offline-first architecture (PWA)
- [ ] Export/import save states
- [ ] Cloud save sync (optional)

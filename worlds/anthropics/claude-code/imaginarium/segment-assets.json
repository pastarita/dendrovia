[
  {
    "segmentId": "seg-441bc646",
    "palette": {
      "primary": "#00383c",
      "secondary": "#331223",
      "accent": "#612c05",
      "background": "#000505",
      "glow": "#005d63",
      "mood": "cool"
    },
    "noise": {
      "type": "fbm",
      "octaves": 1,
      "frequency": 4,
      "amplitude": 0.48061799739838873,
      "seed": 78290
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&H]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-441bc646-76733802",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 7673380238f0ee573a2f9c6a61ef98cf537ecd8314e0a8de55a1b78c5a045f3d\n// Variant: segment-seg-441bc646\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=1, freq=4.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.433, 1.75, 0.5), vec3(0.866, 2.5, 1.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.433, 1.75, 0.5), vec3(0.866, 2.5, 1.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0,
        "u_color1.g": 0.2196078431372549,
        "u_color1.b": 0.23529411764705882,
        "u_color2.r": 0.2,
        "u_color2.g": 0.07058823529411765,
        "u_color2.b": 0.13725490196078433,
        "u_color3.r": 0.3803921568627451,
        "u_color3.g": 0.17254901960784313,
        "u_color3.b": 0.0196078431372549,
        "u_glow.r": 0,
        "u_glow.g": 0.36470588235294116,
        "u_glow.b": 0.38823529411764707,
        "u_background.r": 0,
        "u_background.g": 0.0196078431372549,
        "u_background.b": 0.0196078431372549,
        "time": 0
      },
      "complexity": 297
    }
  },
  {
    "segmentId": "seg-f1329092",
    "palette": {
      "primary": "#42878b",
      "secondary": "#734b5e",
      "accent": "#cb8c69",
      "background": "#000505",
      "glow": "#62d6dc",
      "mood": "cool"
    },
    "noise": {
      "type": "fbm",
      "octaves": 1,
      "frequency": 1.7000000000000002,
      "amplitude": 0.43979400086720377,
      "seed": 56800
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-f1329092-4cf8d88c",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 4cf8d88cd83189ba6455ab024531bee1750b848348e927a9b530d196235f00b5\n// Variant: segment-seg-f1329092\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=1, freq=1.7000000000000002\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.25882352941176473,
        "u_color1.g": 0.5294117647058824,
        "u_color1.b": 0.5450980392156862,
        "u_color2.r": 0.45098039215686275,
        "u_color2.g": 0.29411764705882354,
        "u_color2.b": 0.3686274509803922,
        "u_color3.r": 0.796078431372549,
        "u_color3.g": 0.5490196078431373,
        "u_color3.b": 0.4117647058823529,
        "u_glow.r": 0.3843137254901961,
        "u_glow.g": 0.8392156862745098,
        "u_glow.b": 0.8627450980392157,
        "u_background.r": 0,
        "u_background.g": 0.0196078431372549,
        "u_background.b": 0.0196078431372549,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-1ebb7162",
    "palette": {
      "primary": "#92b3cb",
      "secondary": "#767f9a",
      "accent": "#e4d5ff",
      "background": "#010407",
      "glow": "#e2ffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.4204119982655925,
      "seed": 38605
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-1ebb7162-0b63d188",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 0b63d1887f3425841f84f8e726dfdf0fb7d31518c718555ad6b1a6a5d92d8f0a\n// Variant: segment-seg-1ebb7162\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5725490196078431,
        "u_color1.g": 0.7019607843137254,
        "u_color1.b": 0.796078431372549,
        "u_color2.r": 0.4627450980392157,
        "u_color2.g": 0.4980392156862745,
        "u_color2.b": 0.6039215686274509,
        "u_color3.r": 0.8941176470588236,
        "u_color3.g": 0.8352941176470589,
        "u_color3.b": 1,
        "u_glow.r": 0.8862745098039215,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.027450980392156862,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-87589118",
    "palette": {
      "primary": "#4d8e81",
      "secondary": "#71516d",
      "accent": "#d78e82",
      "background": "#000503",
      "glow": "#74e1cc",
      "mood": "cool"
    },
    "noise": {
      "type": "fbm",
      "octaves": 1,
      "frequency": 1.5142857142857142,
      "amplitude": 0.5557507201905658,
      "seed": 12082
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-87589118-f9a59dfe",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: f9a59dfed4c73dc1bcaaad90c028fe1763940bbdfc3fc7a4c0dbfb5882e58790\n// Variant: segment-seg-87589118\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=1, freq=1.5142857142857142\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.30196078431372547,
        "u_color1.g": 0.5568627450980392,
        "u_color1.b": 0.5058823529411764,
        "u_color2.r": 0.44313725490196076,
        "u_color2.g": 0.3176470588235294,
        "u_color2.b": 0.42745098039215684,
        "u_color3.r": 0.8431372549019608,
        "u_color3.g": 0.5568627450980392,
        "u_color3.b": 0.5098039215686274,
        "u_glow.r": 0.4549019607843137,
        "u_glow.g": 0.8823529411764706,
        "u_glow.b": 0.8,
        "u_background.r": 0,
        "u_background.g": 0.0196078431372549,
        "u_background.b": 0.011764705882352941,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-facf7bbe",
    "palette": {
      "primary": "#679777",
      "secondary": "#6d5c81",
      "accent": "#e399a9",
      "background": "#000502",
      "glow": "#a0eebb",
      "mood": "neutral"
    },
    "noise": {
      "type": "fbm",
      "octaves": 1,
      "frequency": 1.175,
      "amplitude": 0.45563025007672875,
      "seed": 45468
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-facf7bbe-0b6ce54a",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 0b6ce54a46efdab2fed1853a9cf54f41c494b5a11f0f23742eeaf15825b97bf5\n// Variant: segment-seg-facf7bbe\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=1, freq=1.175\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.403921568627451,
        "u_color1.g": 0.592156862745098,
        "u_color1.b": 0.4666666666666667,
        "u_color2.r": 0.42745098039215684,
        "u_color2.g": 0.3607843137254902,
        "u_color2.b": 0.5058823529411764,
        "u_color3.r": 0.8901960784313725,
        "u_color3.g": 0.6,
        "u_color3.b": 0.6627450980392157,
        "u_glow.r": 0.6274509803921569,
        "u_glow.g": 0.9333333333333333,
        "u_glow.b": 0.7333333333333333,
        "u_background.r": 0,
        "u_background.g": 0.0196078431372549,
        "u_background.b": 0.00784313725490196,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-df2330e2",
    "palette": {
      "primary": "#51969a",
      "secondary": "#7f5669",
      "accent": "#df9f7b",
      "background": "#000505",
      "glow": "#7aedf3",
      "mood": "cool"
    },
    "noise": {
      "type": "fbm",
      "octaves": 1,
      "frequency": 1.2,
      "amplitude": 0.7292256071356477,
      "seed": 40643
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-df2330e2-3a6b4425",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 3a6b4425c0ef9ebcd13ecc5a47efdfee90dc2c6b5ce56be1239512eec35e96c2\n// Variant: segment-seg-df2330e2\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=1, freq=1.2\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.3176470588235294,
        "u_color1.g": 0.5882352941176471,
        "u_color1.b": 0.6039215686274509,
        "u_color2.r": 0.4980392156862745,
        "u_color2.g": 0.33725490196078434,
        "u_color2.b": 0.4117647058823529,
        "u_color3.r": 0.8745098039215686,
        "u_color3.g": 0.6235294117647059,
        "u_color3.b": 0.4823529411764706,
        "u_glow.r": 0.47843137254901963,
        "u_glow.g": 0.9294117647058824,
        "u_glow.b": 0.9529411764705882,
        "u_background.r": 0,
        "u_background.g": 0.0196078431372549,
        "u_background.b": 0.0196078431372549,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-57802565",
    "palette": {
      "primary": "#0074ff",
      "secondary": "#d9003b",
      "accent": "#26d700",
      "background": "#000027",
      "glow": "#00aeff",
      "mood": "cool"
    },
    "noise": {
      "type": "worley",
      "octaves": 8,
      "frequency": 1.2333333333333334,
      "amplitude": 0.46901960800285136,
      "seed": 25923
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 38
    },
    "shader": {
      "id": "sdf-segment-seg-57802565-36243561",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 36243561334938a4b27c4b21236fa5e4edb79dc62faed48d140b50345a130cfb\n// Variant: segment-seg-57802565\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: worley, octaves=8, freq=1.2333333333333334\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.616, 1.788, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.616, 1.788, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.788, 0.616), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.788, -0.616), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.485, 1.621, 0.616), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.616, 1.788, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.616, 1.788, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.788, 0.616), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.788, -0.616), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.485, 1.621, 0.616), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0,
        "u_color1.g": 0.4549019607843137,
        "u_color1.b": 1,
        "u_color2.r": 0.8509803921568627,
        "u_color2.g": 0,
        "u_color2.b": 0.23137254901960785,
        "u_color3.r": 0.14901960784313725,
        "u_color3.g": 0.8431372549019608,
        "u_color3.b": 0,
        "u_glow.r": 0,
        "u_glow.g": 0.6823529411764706,
        "u_glow.b": 1,
        "u_background.r": 0,
        "u_background.g": 0,
        "u_background.b": 0.15294117647058825,
        "time": 0
      },
      "complexity": 298
    }
  }
]
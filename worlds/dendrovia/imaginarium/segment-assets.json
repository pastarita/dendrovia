[
  {
    "segmentId": "seg-edd4803a",
    "palette": {
      "primary": "#a7b492",
      "secondary": "#6d8875",
      "accent": "#adede4",
      "background": "#030401",
      "glow": "#ffffe2",
      "mood": "neutral"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.4204119982655925,
      "seed": 38605
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 3,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-edd4803a-f19c681e",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: f19c681e942af10385f74f84178545a48a085fc3aacc8562968f324ff2ed2feb\n// Variant: segment-seg-edd4803a\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.342, 2.94, 0.0), 0.12249999999999998);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.985, 2.706, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.342, 2.94, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.985, 2.706, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.6549019607843137,
        "u_color1.g": 0.7058823529411765,
        "u_color1.b": 0.5725490196078431,
        "u_color2.r": 0.42745098039215684,
        "u_color2.g": 0.5333333333333333,
        "u_color2.b": 0.4588235294117647,
        "u_color3.r": 0.6784313725490196,
        "u_color3.g": 0.9294117647058824,
        "u_color3.b": 0.8941176470588236,
        "u_glow.r": 1,
        "u_glow.g": 1,
        "u_glow.b": 0.8862745098039215,
        "u_background.r": 0.011764705882352941,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.00392156862745098,
        "time": 0
      },
      "complexity": 300
    }
  },
  {
    "segmentId": "seg-f2d5decd",
    "palette": {
      "primary": "#84b7c8",
      "secondary": "#6a839d",
      "accent": "#d3d9ff",
      "background": "#000406",
      "glow": "#ccffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 2,
      "frequency": 1,
      "amplitude": 0.46901960800285136,
      "seed": 63116
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 3,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-f2d5decd-094a02f9",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 094a02f9c6efafada89f98d58323d03442a0f54c4539567213b85a421cb42d14\n// Variant: segment-seg-f2d5decd\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=2, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.342, 2.94, 0.0), 0.12249999999999998);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.985, 2.706, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.342, 2.94, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.342, 1.94, 0.0), vec3(-0.985, 2.706, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5176470588235295,
        "u_color1.g": 0.7176470588235294,
        "u_color1.b": 0.7843137254901961,
        "u_color2.r": 0.41568627450980394,
        "u_color2.g": 0.5137254901960784,
        "u_color2.b": 0.615686274509804,
        "u_color3.r": 0.8274509803921568,
        "u_color3.g": 0.8509803921568627,
        "u_color3.b": 1,
        "u_glow.r": 0.8,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.023529411764705882,
        "time": 0
      },
      "complexity": 300
    }
  },
  {
    "segmentId": "seg-4d7c7fb3",
    "palette": {
      "primary": "#00ece2",
      "secondary": "#00a4e6",
      "accent": "#00f2ff",
      "background": "#000808",
      "glow": "#00ffff",
      "mood": "cool"
    },
    "noise": {
      "type": "perlin",
      "octaves": 6,
      "frequency": 1,
      "amplitude": 0.508278537031645,
      "seed": 42900
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 3,
      "angle": 23
    },
    "shader": {
      "id": "sdf-segment-seg-4d7c7fb3-a64b8d1d",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: a64b8d1d86e0638e4ed7c94651a3849708756b99939d78881183359ee8b041eb\n// Variant: segment-seg-4d7c7fb3\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: perlin, octaves=6, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(-0.391, 1.921, 0.0), vec3(-0.391, 2.921, 0.0), 0.12249999999999998);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.391, 1.921, 0.0), vec3(-1.11, 2.615, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.391, 1.921, 0.0), vec3(-0.391, 2.921, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.391, 1.921, 0.0), vec3(-1.11, 2.615, 0.0), 0.12249999999999998), 0.24999999999999997);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0,
        "u_color1.g": 0.9254901960784314,
        "u_color1.b": 0.8862745098039215,
        "u_color2.r": 0,
        "u_color2.g": 0.6431372549019608,
        "u_color2.b": 0.9019607843137255,
        "u_color3.r": 0,
        "u_color3.g": 0.9490196078431372,
        "u_color3.b": 1,
        "u_glow.r": 0,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0,
        "u_background.g": 0.03137254901960784,
        "u_background.b": 0.03137254901960784,
        "time": 0
      },
      "complexity": 300
    }
  }
]
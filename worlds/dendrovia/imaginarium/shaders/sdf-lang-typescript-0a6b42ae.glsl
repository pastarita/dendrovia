// ============================================================
// DENDROVIA Raymarcher â€” Generated by IMAGINARIUM
// Seed: 0a6b42ae8802a8818af6aeffbd60c213daf7e4c9a3cb22c09896a5264762c020
// Variant: lang-typescript
// ============================================================

precision highp float;

uniform float time;
uniform vec2 resolution;
uniform vec3 u_color1;
uniform vec3 u_color2;
uniform vec3 u_color3;
uniform vec3 u_glow;
uniform vec3 u_background;

// --- SDF Library ---
// ============================================================
// SDF Primitive Library
// Based on Inigo Quilez: iquilezles.org/articles/distfunctions
// ============================================================

float sdSphere(vec3 p, float r) {
  return length(p) - r;
}

float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
  vec3 pa = p - a;
  vec3 ba = b - a;
  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
  return length(pa - ba * h) - r;
}

float sdRoundCone(vec3 p, float r1, float r2, float h) {
  vec2 q = vec2(length(p.xz), p.y);
  float b = (r1 - r2) / h;
  float a = sqrt(1.0 - b * b);
  float k = dot(q, vec2(-b, a));
  if (k < 0.0) return length(q) - r1;
  if (k > a * h) return length(q - vec2(0.0, h)) - r2;
  return dot(q, vec2(a, b)) - r1;
}

float sdCappedCone(vec3 p, float h, float r1, float r2) {
  vec2 q = vec2(length(p.xz), p.y);
  vec2 k1 = vec2(r2, h);
  vec2 k2 = vec2(r2 - r1, 2.0 * h);
  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);
  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);
  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;
  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));
}

float sdCylinder(vec3 p, float h, float r) {
  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// ============================================================
// Boolean / Blending Operators
// ============================================================

float opUnion(float d1, float d2) {
  return min(d1, d2);
}

float opSubtraction(float d1, float d2) {
  return max(-d1, d2);
}

float opIntersection(float d1, float d2) {
  return max(d1, d2);
}

float opSmoothUnion(float d1, float d2, float k) {
  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
  return mix(d2, d1, h) - k * h * (1.0 - h);
}

float opSmoothSubtraction(float d1, float d2, float k) {
  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
  return mix(d2, -d1, h) + k * h * (1.0 - h);
}

// ============================================================
// Domain Distortion Operators
// ============================================================

vec3 opTwist(vec3 p, float k) {
  float c = cos(k * p.y);
  float s = sin(k * p.y);
  mat2 m = mat2(c, -s, s, c);
  return vec3(m * p.xz, p.y);
}

vec3 opBend(vec3 p, float k) {
  float c = cos(k * p.x);
  float s = sin(k * p.x);
  mat2 m = mat2(c, -s, s, c);
  vec2 q = m * p.xy;
  return vec3(q, p.z);
}


// --- Scene Definition ---
float scene(vec3 p) {
  // Noise: fbm, octaves=4, freq=1.0
  // Displacement applied in applyLighting via surface normal

  float d = sdCapsule(p, vec3(-0.423, 1.906, 0.0), vec3(-0.423, 2.906, 0.0), 0.12249999999999998);
  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.423, 1.906, 0.0), vec3(-1.189, 2.549, 0.0), 0.12249999999999998), 0.24999999999999997);
  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.423, 1.906, 0.0), vec3(-0.423, 2.906, 0.0), 0.12249999999999998), 0.24999999999999997);
  d = opSmoothUnion(d, sdCapsule(p, vec3(-0.423, 1.906, 0.0), vec3(-1.189, 2.549, 0.0), 0.12249999999999998), 0.24999999999999997);
  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.423, 1.906, 0.0), 0.175), 0.3);
  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.423, 1.906, 0.0), 0.175), 0.3);
  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.423, 1.906, 0.0), 0.175), 0.3);
  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.423, 1.906, 0.0), 0.175), 0.3);
  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.423, 1.906, 0.0), 0.175), 0.3);
  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.423, 1.906, 0.0), 0.175), 0.3);
  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);
  return d;
}

// --- Lighting ---
// ============================================================
// Lighting & Color Grading
// Blinn-Phong diffuse + specular, SDF-based AO, edge glow
// ============================================================

vec3 calcNormal(vec3 p) {
  const float h = 0.001;
  const vec2 k = vec2(1.0, -1.0);
  return normalize(
    k.xyy * scene(p + k.xyy * h) +
    k.yyx * scene(p + k.yyx * h) +
    k.yxy * scene(p + k.yxy * h) +
    k.xxx * scene(p + k.xxx * h)
  );
}

float calcAO(vec3 pos, vec3 nor) {
  float occ = 0.0;
  float sca = 1.0;
  for (int i = 0; i < 5; i++) {
    float h = 0.01 + 0.12 * float(i) / 4.0;
    float d = scene(pos + h * nor);
    occ += (h - d) * sca;
    sca *= 0.95;
  }
  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

float calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {
  float res = 1.0;
  float t = tmin;
  for (int i = 0; i < 16; i++) {
    float h = scene(ro + rd * t);
    res = min(res, 8.0 * h / t);
    t += clamp(h, 0.02, 0.10);
    if (res < 0.005 || t > tmax) break;
  }
  return clamp(res, 0.0, 1.0);
}

vec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {
  // Light direction
  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));

  // Diffuse (Lambert)
  float dif = clamp(dot(nor, lig), 0.0, 1.0);

  // Specular (Blinn-Phong)
  vec3 hal = normalize(lig - rd);
  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);

  // Ambient occlusion
  float ao = calcAO(pos, nor);

  // Combine
  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);
  col += spe * 0.3 * glowColor;

  // Edge glow (Fresnel-like)
  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);
  col += fre * 0.4 * glowColor;

  return col;
}


// --- Raymarching ---
void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;

  // Camera
  vec3 ro = vec3(0.0, 2.5, -5.0);
  vec3 ta = vec3(0.0, 2.0, 0.0);
  vec3 ww = normalize(ta - ro);
  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
  vec3 vv = cross(uu, ww);
  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);

  // March
  float t = 0.0;
  float d;
  for (int i = 0; i < 96; i++) {
    vec3 p = ro + rd * t;
    d = scene(p);
    if (d < 0.001 || t > 50.0) break;
    t += d;
  }

  vec3 col = vec3(0.0);

  if (t < 50.0) {
    vec3 pos = ro + rd * t;
    vec3 nor = calcNormal(pos);

    // Base color from palette
    float h = pos.y / 6.0;
    vec3 baseColor;
    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);
    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);
    else baseColor = u_color3;

    col = applyLighting(pos, nor, rd, baseColor, u_glow);

    // Distance fog
    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));
  } else {
    // Background gradient
    col = u_background + rd.y * 0.05 * u_glow;
  }

  // Gamma correction
  col = pow(col, vec3(0.4545));

  gl_FragColor = vec4(col, 1.0);
}

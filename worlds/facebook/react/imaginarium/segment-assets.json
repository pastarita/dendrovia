[
  {
    "segmentId": "seg-8c49f455",
    "palette": {
      "primary": "#92b3cb",
      "secondary": "#767f9a",
      "accent": "#e4d5ff",
      "background": "#010407",
      "glow": "#e2ffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.5894316062684438,
      "seed": 45687
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-8c49f455-322922f4",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 322922f4b9dd93a625ae6e64f307967169ba0c064960c282566b9400cba3032c\n// Variant: segment-seg-8c49f455\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5725490196078431,
        "u_color1.g": 0.7019607843137254,
        "u_color1.b": 0.796078431372549,
        "u_color2.r": 0.4627450980392157,
        "u_color2.g": 0.4980392156862745,
        "u_color2.b": 0.6039215686274509,
        "u_color3.r": 0.8941176470588236,
        "u_color3.g": 0.8352941176470589,
        "u_color3.b": 1,
        "u_glow.r": 0.8862745098039215,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.027450980392156862,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-856653d9",
    "palette": {
      "primary": "#8fb9a9",
      "secondary": "#62888a",
      "accent": "#b2e7ff",
      "background": "#010403",
      "glow": "#ddffff",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.508278537031645,
      "seed": 82838
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-856653d9-9d9dad2e",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 9d9dad2e6c450e54cf50da625518aa86617b1446b5bd6339127d1dd2a6f2548d\n// Variant: segment-seg-856653d9\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.5607843137254902,
        "u_color1.g": 0.7254901960784313,
        "u_color1.b": 0.6627450980392157,
        "u_color2.r": 0.3843137254901961,
        "u_color2.g": 0.5333333333333333,
        "u_color2.b": 0.5411764705882353,
        "u_color3.r": 0.6980392156862745,
        "u_color3.g": 0.9058823529411765,
        "u_color3.b": 1,
        "u_glow.r": 0.8666666666666667,
        "u_glow.g": 1,
        "u_glow.b": 1,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.011764705882352941,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-6f7548c4",
    "palette": {
      "primary": "#98b79e",
      "secondary": "#648981",
      "accent": "#aceaf6",
      "background": "#010402",
      "glow": "#edfff5",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 1,
      "frequency": 1,
      "amplitude": 0.5982723387668545,
      "seed": 59774
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 20
    },
    "shader": {
      "id": "sdf-segment-seg-6f7548c4-ea0e0799",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: ea0e0799ae36e9743caf0356f39fecca8b3c0872387e13394dca7294d9a611f1\n// Variant: segment-seg-6f7548c4\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=1, freq=1.0\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.342, 1.94, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.94, -0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.321, 1.883, 0.342), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.596078431372549,
        "u_color1.g": 0.7176470588235294,
        "u_color1.b": 0.6196078431372549,
        "u_color2.r": 0.39215686274509803,
        "u_color2.g": 0.5372549019607843,
        "u_color2.b": 0.5058823529411764,
        "u_color3.r": 0.6745098039215687,
        "u_color3.g": 0.9176470588235294,
        "u_color3.b": 0.9647058823529412,
        "u_glow.r": 0.9294117647058824,
        "u_glow.g": 1,
        "u_glow.b": 0.9607843137254902,
        "u_background.r": 0.00392156862745098,
        "u_background.g": 0.01568627450980392,
        "u_background.b": 0.00784313725490196,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-a1a1affa",
    "palette": {
      "primary": "#009aa1",
      "secondary": "#894c6a",
      "accent": "#f39157",
      "background": "#000506",
      "glow": "#00f4ff",
      "mood": "cool"
    },
    "noise": {
      "type": "fbm",
      "octaves": 2,
      "frequency": 1.26,
      "amplitude": 1,
      "seed": 62966
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-a1a1affa-a66610cd",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: a66610cd2b84f366623263327b2ea54a1735d9840d0e68c520e19b11d33d5bd1\n// Variant: segment-seg-a1a1affa\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=2, freq=1.26\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0,
        "u_color1.g": 0.6039215686274509,
        "u_color1.b": 0.6313725490196078,
        "u_color2.r": 0.5372549019607843,
        "u_color2.g": 0.2980392156862745,
        "u_color2.b": 0.41568627450980394,
        "u_color3.r": 0.9529411764705882,
        "u_color3.g": 0.5686274509803921,
        "u_color3.b": 0.3411764705882353,
        "u_glow.r": 0,
        "u_glow.g": 0.9568627450980393,
        "u_glow.b": 1,
        "u_background.r": 0,
        "u_background.g": 0.0196078431372549,
        "u_background.b": 0.023529411764705882,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-cffe9889",
    "palette": {
      "primary": "#c47900",
      "secondary": "#007598",
      "accent": "#9ea1ff",
      "background": "#0b0100",
      "glow": "#ffbc00",
      "mood": "neutral"
    },
    "noise": {
      "type": "fbm",
      "octaves": 3,
      "frequency": 1.1,
      "amplitude": 0.8366094076477699,
      "seed": 48678
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 30
    },
    "shader": {
      "id": "sdf-segment-seg-cffe9889-7a6fbd78",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 7a6fbd78402f9db91ca5a1719ab649cdf69707738541f56bf3e8b8a184247623\n// Variant: segment-seg-cffe9889\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: fbm, octaves=3, freq=1.1\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.5, 1.866, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.866, -0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.433, 1.75, 0.5), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0.7686274509803922,
        "u_color1.g": 0.4745098039215686,
        "u_color1.b": 0,
        "u_color2.r": 0,
        "u_color2.g": 0.4588235294117647,
        "u_color2.b": 0.596078431372549,
        "u_color3.r": 0.6196078431372549,
        "u_color3.g": 0.6313725490196078,
        "u_color3.b": 1,
        "u_glow.r": 1,
        "u_glow.g": 0.7372549019607844,
        "u_glow.b": 0,
        "u_background.r": 0.043137254901960784,
        "u_background.g": 0.00392156862745098,
        "u_background.b": 0,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-643e9998",
    "palette": {
      "primary": "#ff0083",
      "secondary": "#ff0000",
      "accent": "#ff7a00",
      "background": "#1a0000",
      "glow": "#ff00c9",
      "mood": "warm"
    },
    "noise": {
      "type": "perlin",
      "octaves": 8,
      "frequency": 1.2,
      "amplitude": 0.515836249209525,
      "seed": 43092
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 23
    },
    "shader": {
      "id": "sdf-segment-seg-643e9998-cb4cc7a5",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: cb4cc7a5c467ba0b1450ef4c4476bc435f2bdbabe6a77b8e6870fbefc0ed884b\n// Variant: segment-seg-643e9998\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: perlin, octaves=8, freq=1.2\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.391, 1.921, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.921, 0.391), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.921, -0.391), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.36, 1.847, 0.391), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.391, 1.921, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.921, 0.391), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.921, -0.391), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.36, 1.847, 0.391), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 1,
        "u_color1.g": 0,
        "u_color1.b": 0.5137254901960784,
        "u_color2.r": 1,
        "u_color2.g": 0,
        "u_color2.b": 0,
        "u_color3.r": 1,
        "u_color3.g": 0.47843137254901963,
        "u_color3.b": 0,
        "u_glow.r": 1,
        "u_glow.g": 0,
        "u_glow.b": 0.788235294117647,
        "u_background.r": 0.10196078431372549,
        "u_background.g": 0,
        "u_background.b": 0,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-8ae3ce54",
    "palette": {
      "primary": "#00746f",
      "secondary": "#700259",
      "accent": "#db0000",
      "background": "#000706",
      "glow": "#00bab3",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 8,
      "frequency": 1.389655172413793,
      "amplitude": 0.9666088059646976,
      "seed": 5009
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 28
    },
    "shader": {
      "id": "sdf-segment-seg-8ae3ce54-7ce10854",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: 7ce1085458375fc2267871be9d74019693fd79c20cb3124f51fef7b4619cde55\n// Variant: segment-seg-8ae3ce54\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=8, freq=1.389655172413793\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.469, 1.883, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.469, 1.883, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, -0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.415, 1.78, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.469, 1.883, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.469, 1.883, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, -0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.415, 1.78, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0,
        "u_color1.g": 0.4549019607843137,
        "u_color1.b": 0.43529411764705883,
        "u_color2.r": 0.4392156862745098,
        "u_color2.g": 0.00784313725490196,
        "u_color2.b": 0.34901960784313724,
        "u_color3.r": 0.8588235294117647,
        "u_color3.g": 0,
        "u_color3.b": 0,
        "u_glow.r": 0,
        "u_glow.g": 0.7294117647058823,
        "u_glow.b": 0.7019607843137254,
        "u_background.r": 0,
        "u_background.g": 0.027450980392156862,
        "u_background.b": 0.023529411764705882,
        "time": 0
      },
      "complexity": 298
    }
  },
  {
    "segmentId": "seg-9a4652f2",
    "palette": {
      "primary": "#007d78",
      "secondary": "#780d60",
      "accent": "#e81900",
      "background": "#000706",
      "glow": "#00c8c0",
      "mood": "cool"
    },
    "noise": {
      "type": "simplex",
      "octaves": 8,
      "frequency": 1.1,
      "amplitude": 0.7636126669925523,
      "seed": 56167
    },
    "lsystem": {
      "axiom": "F",
      "rules": {
        "F": "F[+F][-F][&F][^F][+&F]",
        "H": "FF[+&F][-^F]"
      },
      "iterations": 5,
      "angle": 28
    },
    "shader": {
      "id": "sdf-segment-seg-9a4652f2-da5dfe12",
      "glsl": "// ============================================================\n// DENDROVIA Raymarcher — Generated by IMAGINARIUM\n// Seed: da5dfe12ce510c324721dc9be9132b8b359170104487a8d6d787b2976f541a52\n// Variant: segment-seg-9a4652f2\n// ============================================================\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform vec3 u_glow;\nuniform vec3 u_background;\n\n// --- SDF Library ---\n// ============================================================\n// SDF Primitive Library\n// Based on Inigo Quilez: iquilezles.org/articles/distfunctions\n// ============================================================\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  vec2 q = vec2(length(p.xz), p.y);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.0) return length(q) - r1;\n  if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// ============================================================\n// Boolean / Blending Operators\n// ============================================================\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n// ============================================================\n// Domain Distortion Operators\n// ============================================================\n\nvec3 opTwist(vec3 p, float k) {\n  float c = cos(k * p.y);\n  float s = sin(k * p.y);\n  mat2 m = mat2(c, -s, s, c);\n  return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec2 q = m * p.xy;\n  return vec3(q, p.z);\n}\n\n\n// --- Scene Definition ---\nfloat scene(vec3 p) {\n  // Noise: simplex, octaves=8, freq=1.1\n  // Displacement applied in applyLighting via surface normal\n\n  float d = sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.469, 1.883, 0.0), 0.175);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.469, 1.883, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, -0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.415, 1.78, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.469, 1.883, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(-0.469, 1.883, 0.0), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.0, 1.883, -0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 1.0, 0.0), vec3(0.415, 1.78, 0.469), 0.175), 0.3);\n  d = opSmoothUnion(d, sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25), 0.35);\n  return d;\n}\n\n// --- Lighting ---\n// ============================================================\n// Lighting & Color Grading\n// Blinn-Phong diffuse + specular, SDF-based AO, edge glow\n// ============================================================\n\nvec3 calcNormal(vec3 p) {\n  const float h = 0.001;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(\n    k.xyy * scene(p + k.xyy * h) +\n    k.yyx * scene(p + k.yyx * h) +\n    k.yxy * scene(p + k.yxy * h) +\n    k.xxx * scene(p + k.xxx * h)\n  );\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.12 * float(i) / 4.0;\n    float d = scene(pos + h * nor);\n    occ += (h - d) * sca;\n    sca *= 0.95;\n  }\n  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t);\n    res = min(res, 8.0 * h / t);\n    t += clamp(h, 0.02, 0.10);\n    if (res < 0.005 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 applyLighting(vec3 pos, vec3 nor, vec3 rd, vec3 baseColor, vec3 glowColor) {\n  // Light direction\n  vec3 lig = normalize(vec3(0.6, 0.8, -0.5));\n\n  // Diffuse (Lambert)\n  float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n  // Specular (Blinn-Phong)\n  vec3 hal = normalize(lig - rd);\n  float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n\n  // Ambient occlusion\n  float ao = calcAO(pos, nor);\n\n  // Combine\n  vec3 col = baseColor * (0.15 + 0.65 * dif * ao);\n  col += spe * 0.3 * glowColor;\n\n  // Edge glow (Fresnel-like)\n  float fre = pow(1.0 - abs(dot(nor, -rd)), 3.0);\n  col += fre * 0.4 * glowColor;\n\n  return col;\n}\n\n\n// --- Raymarching ---\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;\n\n  // Camera\n  vec3 ro = vec3(0.0, 2.5, -5.0);\n  vec3 ta = vec3(0.0, 2.0, 0.0);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);\n\n  // March\n  float t = 0.0;\n  float d;\n  for (int i = 0; i < 96; i++) {\n    vec3 p = ro + rd * t;\n    d = scene(p);\n    if (d < 0.001 || t > 50.0) break;\n    t += d;\n  }\n\n  vec3 col = vec3(0.0);\n\n  if (t < 50.0) {\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // Base color from palette\n    float h = pos.y / 6.0;\n    vec3 baseColor;\n    if (h < 0.33) baseColor = mix(u_color1, u_color2, h * 3.0);\n    else if (h < 0.66) baseColor = mix(u_color2, u_color3, (h - 0.33) * 3.0);\n    else baseColor = u_color3;\n\n    col = applyLighting(pos, nor, rd, baseColor, u_glow);\n\n    // Distance fog\n    col = mix(col, u_background, 1.0 - exp(-0.02 * t * t));\n  } else {\n    // Background gradient\n    col = u_background + rd.y * 0.05 * u_glow;\n  }\n\n  // Gamma correction\n  col = pow(col, vec3(0.4545));\n\n  gl_FragColor = vec4(col, 1.0);\n}\n",
      "parameters": {
        "u_color1.r": 0,
        "u_color1.g": 0.49019607843137253,
        "u_color1.b": 0.47058823529411764,
        "u_color2.r": 0.47058823529411764,
        "u_color2.g": 0.050980392156862744,
        "u_color2.b": 0.3764705882352941,
        "u_color3.r": 0.9098039215686274,
        "u_color3.g": 0.09803921568627451,
        "u_color3.b": 0,
        "u_glow.r": 0,
        "u_glow.g": 0.7843137254901961,
        "u_glow.b": 0.7529411764705882,
        "u_background.r": 0,
        "u_background.g": 0.027450980392156862,
        "u_background.b": 0.023529411764705882,
        "time": 0
      },
      "complexity": 298
    }
  }
]